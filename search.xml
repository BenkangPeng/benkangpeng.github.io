<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Typora语法</title>
    <url>/2023/09/18/Typora%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Typora是一个基于markdown语法的轻量级软件，以下是我在学习markdown语法时的一些笔记。</p>

<span id="more"></span>

<p><a href="https://pan.baidu.com/s/1A0PSXm8SgOlyFYxgQ7yaDg?pwd=jwuf#list/path=%2F">Typora软件分享</a>提取码：jwuf</p>
<h3 id="Living-preview"><a href="#Living-preview" class="headerlink" title="Living preview"></a>Living preview</h3><p>Living preview(实时预览)这也算是Typora的一个特点吧相当于有道云笔记中的右窗口预览，<strong>可自动隐去格式说明中的格式语句</strong> 。 注意一定要在符号与正文之间<strong>加空格</strong>，目的在于区分内容与格式符。文字换行也与一般不同，要<strong>先加空格再enter</strong>。</p>
<h3 id="具体符号"><a href="#具体符号" class="headerlink" title="具体符号"></a>具体符号</h3><h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4><p>随着标题的井字符数量的增加，标题优先级逐渐下降。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 大标题  （ Ctrl + 1 ） </span><br><span class="line">## 第二号标题 （ Ctrl + 2 ) </span><br><span class="line">### 第三号标题  </span><br><span class="line">一直可以到第六号标题</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Blockquote"><a href="#Blockquote" class="headerlink" title="Blockquote"></a>Blockquote</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法 ： &gt; 引用内容  </span><br><span class="line">例如输入下列语句：</span><br><span class="line">&gt; 心志要坚，意趣要乐。  </span><br><span class="line">输出结果为</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>心志要坚，意趣要乐</p>
</blockquote>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">就如平常一样输入序号就行了，此后换行就会自动排序。  </span><br><span class="line">格式 ：1. 第一点        </span><br><span class="line">2. 第二点</span><br><span class="line">3. * 空圆</span><br><span class="line">   - 方形</span><br><span class="line">* 实圆</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>第一点</li>
<li>第二点</li>
<li><ul>
<li><h2 id="星号"><a href="#星号" class="headerlink" title="星号"></a>星号</h2></li>
</ul>
</li>
</ol>
<p>- </p>
<h4 id="Task-List"><a href="#Task-List" class="headerlink" title="Task List"></a>Task List</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式 </span><br><span class="line">- [ ] 未完成任务    - [x] 已完成任务</span><br><span class="line">可点击任务点完成任务  </span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>未完成任务    </li>
<li>已完成任务</li>
</ul>
<h4 id="Code-Block"><a href="#Code-Block" class="headerlink" title="Code Block"></a>Code Block</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式  </span><br><span class="line">​```language</span><br><span class="line">代码段</span><br><span class="line">​```  </span><br><span class="line">其实后面那三个顿号电脑会自动显示的（注意是顿号，  </span><br><span class="line">英文输入法下的Esc下边那个键）  </span><br><span class="line">代码段也有一个神奇的功能，就是能完整显示Typora的代码符，   </span><br><span class="line">要不然本文的一个个事例又是怎么保留住这些Typora符呢。想想也知道，  </span><br><span class="line">设计一个这样的文本格式，  </span><br><span class="line">当然也要兼顾代码的特殊符号呀，比如代码里的#、*是不能参与Typora的格式符的。  </span><br><span class="line">代码语句的输入  </span><br><span class="line">格式 </span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Reverse Bits Ordering</span><br><span class="line">module top_module(</span><br><span class="line">    input [99:0] in ,</span><br><span class="line">    output [99:0] out </span><br><span class="line">) ;</span><br><span class="line">    genvar i ;</span><br><span class="line">    generate</span><br><span class="line">        for(i = 0 ; i &lt; 100 ; i++) begin : generate_name</span><br><span class="line">            assign out[i] = in [99 - i] ;</span><br><span class="line">        end</span><br><span class="line">    endgenerate</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<h4 id="Math-Blocks"><a href="#Math-Blocks" class="headerlink" title="Math Blocks"></a>Math Blocks</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ 单行输入 $</span><br><span class="line">$ \mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  \begin&#123;vmatrix&#125;</span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;  </span><br><span class="line">$</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| A  | B |</span><br><span class="line">| C  | D |</span><br><span class="line">| E  | F |  </span><br><span class="line">点击表格内有功能选择</span><br></pre></td></tr></table></figure>
</blockquote>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">C</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">F</td>
</tr>
</tbody></table>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式 </span><br><span class="line">--- </span><br><span class="line">或者 </span><br><span class="line">*** </span><br><span class="line">例如 </span><br><span class="line">我是分割线 </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">我是分割线 </span><br><span class="line"></span><br><span class="line">***</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我是分割线 </p>
<hr>
<p>我是分割线 </p>
<hr>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式 </span><br><span class="line">输入[toc]再回车就行了 （table of content) </span><br><span class="line">就会生成一个目录，点击相应标记即可跳转 </span><br><span class="line">例如 </span><br><span class="line">[toc] </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式 </span><br><span class="line">[给链接起个名字](写上具体网址)</span><br><span class="line">[知乎](https://www.zhihu.com/) 注意用英文输入法下的括号  </span><br><span class="line">在markdown文件中按住Ctrl键同时点击网址即可直接打开</span><br></pre></td></tr></table></figure>
</blockquote>
<p><a href="www.zhihu.com">知乎</a></p>
<h4 id="Insert-Pictures"><a href="#Insert-Pictures" class="headerlink" title="Insert Pictures"></a>Insert Pictures</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式  </span><br><span class="line">![起个名字](存储位置) </span><br><span class="line">例如 </span><br><span class="line">![思维导图](D:\desktop\Typora.png) </span><br><span class="line">当然啦，直接把图片拖过来复制一下不香吗</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>可将typora设置如下，可避免图片丢失导致markdown文件中图片无法查看（也可以使用网络图床存储）</p>
<p><img src="file://D:/Software/Typora/Pictures/1693142385073.png?lastModify=1695005959" alt="img"></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>软件使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/09/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>HDLBits Solutions</title>
    <url>/2023/10/01/NotesOfHdlbits/</url>
    <content><![CDATA[<h3>Abstract</h3>

<p>The solutions and my notes of <a href="[Problem sets - HDLBits (01xz.net)](https://hdlbits.01xz.net/wiki/Problem_sets)">HDLBits</a> are written in this document .</p>

<span id="more"></span>

<p>[TOC]</p>
<h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><h3 id="Getting-Started-1"><a href="#Getting-Started-1" class="headerlink" title="Getting Started"></a>Getting Started</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( <span class="keyword">output</span> one );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">assign</span> one = <span class="number">1&#x27;b1</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Output-Zero"><a href="#Output-Zero" class="headerlink" title="Output Zero"></a>Output Zero</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module ( <span class="keyword">output</span> zero );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">assign</span> zero = <span class="number">1&#x27;b0</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h1 id="Verilog-Language"><a href="#Verilog-Language" class="headerlink" title="Verilog Language"></a>Verilog Language</h1><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><h3 id="Simple-wire"><a href="#Simple-wire" class="headerlink" title="Simple wire"></a>Simple wire</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( <span class="keyword">input</span> in, <span class="keyword">output</span> out );</span><br><span class="line">	<span class="keyword">assign</span> out = in;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Four-wires"><a href="#Four-wires" class="headerlink" title="Four wires"></a>Four wires</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">	<span class="keyword">input</span> a,</span><br><span class="line">	<span class="keyword">input</span> b,</span><br><span class="line">	<span class="keyword">input</span> c,</span><br><span class="line">	<span class="keyword">output</span> w,</span><br><span class="line">	<span class="keyword">output</span> x,</span><br><span class="line">	<span class="keyword">output</span> y,</span><br><span class="line">	<span class="keyword">output</span> z  );</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">assign</span> w = a;</span><br><span class="line">	<span class="keyword">assign</span> x = b;</span><br><span class="line">	<span class="keyword">assign</span> y = b;</span><br><span class="line">	<span class="keyword">assign</span> z = c;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we&#x27;re certain about the width of each signal, using </span></span><br><span class="line">	<span class="comment">// the concatenation operator is equivalent and shorter:</span></span><br><span class="line">	<span class="comment">// assign &#123;w,x,y,z&#125; = &#123;a,b,b,c&#125;;</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Inverter"><a href="#Inverter" class="headerlink" title="Inverter"></a>Inverter</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">	<span class="keyword">input</span> in,</span><br><span class="line">	<span class="keyword">output</span> out</span><br><span class="line">);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">assign</span> out = ~in;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AND-gate"><a href="#AND-gate" class="headerlink" title="AND gate"></a>AND gate</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b, </span><br><span class="line">    <span class="keyword">output</span> out );</span><br><span class="line">	<span class="keyword">assign</span> out = a &amp; b ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="NOR-gate"><a href="#NOR-gate" class="headerlink" title="NOR gate"></a>NOR gate</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> a, </span><br><span class="line">    <span class="keyword">input</span> b, </span><br><span class="line">    <span class="keyword">output</span> out );</span><br><span class="line">    <span class="keyword">assign</span> out = ! (a | b) ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="XNOR-gate"><a href="#XNOR-gate" class="headerlink" title="XNOR gate"></a>XNOR gate</h3><h3 id="Declaring-wires"><a href="#Declaring-wires" class="headerlink" title="Declaring wires"></a>Declaring wires</h3><h3 id="7458-chip"><a href="#7458-chip" class="headerlink" title="7458 chip"></a>7458 chip</h3><h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h2><h3 id="Vectors-1"><a href="#Vectors-1" class="headerlink" title="Vectors"></a>Vectors</h3><h2 id="More-Verilog-Features"><a href="#More-Verilog-Features" class="headerlink" title="More Verilog Features"></a>More Verilog Features</h2><h3 id="Combinational-for-loop-Vector-reversal-2"><a href="#Combinational-for-loop-Vector-reversal-2" class="headerlink" title="*Combinational for-loop : Vector reversal 2"></a>*Combinational for-loop : Vector reversal 2</h3><blockquote>
<p>Given a 100-bit input vector [99:0], reverse its bit ordering.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// False Vesion</span></span><br><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] in ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">99</span>:<span class="number">0</span>] out </span><br><span class="line">) ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">assign</span> out[i] = in [<span class="number">99</span> - i] ;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error (10170): Verilog HDL syntax error at top_module.v(6) near text: &quot;for&quot;;  expecting &quot;endmodule&quot;. </span><br></pre></td></tr></table></figure>
</blockquote>
<p>为什么是这样的报错呢？显示在for循环那一行前缺少一个endmodule</p>
<blockquote>
<p>在module内部，只能<strong>声明输入</strong>、<strong>输出端口、内部信号以及使用连续赋值</strong>（<code>assign</code> 语句）来描述硬件电路的连续逻辑</p>
</blockquote>
<p>因此，<code>verilog</code>编译器认为，<code>for</code>循环前应该有一个<code>endmodule</code>以结束该<code>module</code>,此后才能开始<code>for-loop</code>的声明。</p>
<p><strong>为什么Verilog规定Module内部不能声明for-loop?</strong></p>
<blockquote>
<p>当涉及到硬件描述语言（HDL）如Verilog时，有一些关键的设计原则和语法规则是不同于通用编程语言（如C、Python）的。</p>
<p>Verilog 是为硬件设计而设计的，其目的是描述硬件电路的结构和行为，而不是传统意义上的“编程”。在硬件电路中，信号是在不同的时间步长上并行计算的，而不是按顺序执行的像在软件中一样。这导致了一些语法规则的不同。</p>
<p>具体来说，以下是为什么在 Verilog 中不能直接将 <code>for</code> 循环放在模块内部的原因：</p>
<ol>
<li><strong>并行性：</strong> Verilog 中的代码被解释为电路，其中不同的信号在相同的时间步长上并行地计算。这与传统编程语言中的迭代循环不同，后者按顺序执行。在硬件电路中，不同的信号和逻辑是同时计算的，因此 <code>for</code> 循环的概念与硬件的并行性不一致。</li>
<li><strong>延迟和时间问题：</strong> 在 Verilog 中，信号的传播和逻辑运算都需要考虑时间延迟。循环的迭代次数可能需要在编译时已知，但在硬件中，延迟可能会影响电路的行为。如果允许在模块内部使用 <code>for</code> 循环，编译器就需要处理如何在时间上正确地展开循环和处理延迟的问题。</li>
</ol>
<p>为了符合硬件的特性，Verilog 引入了生成语句（generate statements），允许在编译时生成不同的硬件结构，这包括使用 <code>for</code> 循环来生成多个类似的硬件逻辑。生成语句允许在不同的时间步长上并行生成硬件，而不会引入运行时的顺序问题。</p>
</blockquote>
<p>简单说就是：<code>for-loop</code>内不同层次(i &#x3D; 1 , 2 ,3 ……)，体现了顺序的先后，是软件编程的思维；而<code>verilog</code>中<code>assign</code>描述的各硬件是并行运行的，是硬件编程的思维；二者需要区分开来:smile:</p>
<p>我们使用<code>generate</code>来实现(generate生成多个并行计算模块)：[generate介绍](<a href="https://zhuanlan.zhihu.com/p/107047600">Verilog中generate的使用 - 知乎 (zhihu.com)</a>)</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] in ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">99</span>:<span class="number">0</span>] out </span><br><span class="line">) ;</span><br><span class="line">    <span class="keyword">genvar</span> i ;<span class="comment">//state a variable i </span></span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) <span class="keyword">begin</span> : generate_name</span><br><span class="line">            <span class="keyword">assign</span> out[i] = in [<span class="number">99</span> - i] ; <span class="comment">// type of out is wire</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p>或者将<code>for-loop</code>写在<code>always</code>中：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] in ,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">99</span>:<span class="number">0</span>] out </span><br><span class="line">) ;</span><br><span class="line">    <span class="keyword">always</span> @(*)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">$bits</span>(out) ; i++ ) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//$bits(signal)获取信号位长</span></span><br><span class="line">            out[i] = in [ <span class="built_in">$bits</span>(out) - <span class="number">1</span> - i ] ; </span><br><span class="line">            <span class="comment">//type of out is reg</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Combinational-for-loop-255-bit-population-count"><a href="#Combinational-for-loop-255-bit-population-count" class="headerlink" title="Combinational for-loop:255-bit population count"></a>Combinational for-loop:255-bit population count</h3><blockquote>
<p>A “population count” circuit counts the number of ‘1’s in an input vector. Build a population count circuit for a 255-bit input vector.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">254</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] out );</span><br><span class="line">    <span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">       out = <span class="number">0</span> ;<span class="comment">//寄存器型变量在always块中初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">255</span> ; i++) <span class="keyword">begin</span></span><br><span class="line">            out = out + in[i] ; </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Generate-for-loop-1000-bit-binary-adder-2"><a href="#Generate-for-loop-1000-bit-binary-adder-2" class="headerlink" title="Generate for-loop:1000-bit binary adder 2"></a>Generate for-loop:1000-bit binary adder 2</h3><blockquote>
<p>Create a 100-bit binary ripple-carry adder by instantiating 100 <a href="https://hdlbits.01xz.net/wiki/Fadd">full adders</a>. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from <em>each</em> full adder in the ripple-carry adder. cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] a, b,</span><br><span class="line">    <span class="keyword">input</span> cin,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">99</span>:<span class="number">0</span>] cout,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">99</span>:<span class="number">0</span>] sum );</span><br><span class="line">	<span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">genvar</span> i ;<span class="comment">//好像在for循环内声明genvar i 会报错</span></span><br><span class="line">        <span class="keyword">assign</span> sum[<span class="number">0</span>] = a[<span class="number">0</span>] ^ b[<span class="number">0</span>] ^ cin ;</span><br><span class="line">        <span class="keyword">assign</span> cout[<span class="number">0</span>] = a[<span class="number">0</span>] &amp; b[<span class="number">0</span>] | a[<span class="number">0</span>] &amp; cin | b[<span class="number">0</span>] &amp; cin ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; <span class="number">100</span> ; i++) <span class="keyword">begin</span> : generate_name </span><br><span class="line">            <span class="keyword">assign</span> sum[i] = a[i] ^ b[i] ^ cout[i-<span class="number">1</span>] ;</span><br><span class="line">            <span class="keyword">assign</span> cout[i] = a[i] &amp; b[i] | a[i] &amp; cout[i-<span class="number">1</span>] | b[i] &amp; cout[i-<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Generate-for-loop-100-digit-BCD-adder"><a href="#Generate-for-loop-100-digit-BCD-adder" class="headerlink" title="*Generate for-loop:100-digit BCD adder"></a>*Generate for-loop:100-digit BCD adder</h3><blockquote>
<p>You are provided with a BCD one-digit adder named <code>bcd_fadd</code> that adds two BCD digits and carry-in, and produces a sum and carry-out.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module bcd_fadd (</span><br><span class="line">    input [3:0] a,</span><br><span class="line">    input [3:0] b,</span><br><span class="line">    input     cin,</span><br><span class="line">    output   cout,</span><br><span class="line">    output [3:0] sum );</span><br></pre></td></tr></table></figure>

<p>Instantiate 100 copies of <code>bcd_fadd</code> to create a 100-digit BCD ripple-carry adder. Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) and a carry-in to produce a 100-digit sum and carry out.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//False Verion </span></span><br><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">399</span>:<span class="number">0</span>] a, b,</span><br><span class="line">    <span class="keyword">input</span> cin,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> cout,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">399</span>:<span class="number">0</span>] sum );</span><br><span class="line">    <span class="keyword">genvar</span> i , j ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">99</span>:<span class="number">0</span>] temp_cout ;</span><br><span class="line">    <span class="keyword">assign</span> cout = temp_cout[<span class="number">99</span>] ;</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        bcd_fadd U0( a[<span class="number">3</span>:<span class="number">0</span>] , b[<span class="number">3</span>:<span class="number">0</span>] , cin , temp_cout[<span class="number">0</span>] , sum[<span class="number">3</span>:<span class="number">0</span>]) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">7</span> , j = <span class="number">0</span>; i &lt; <span class="number">400</span> ;  i = i + <span class="number">4</span> , j++) <span class="keyword">begin</span> : name </span><br><span class="line">            bcd_fadd U1( a[i:i-<span class="number">3</span>] , b[i:i-<span class="number">3</span>] , temp_cout[j] , sum[i:i-<span class="number">3</span>]) ;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>报错信息：Error (10170): Verilog HDL syntax error at top_module.v(12) near text: “,”;  expecting “;”</p>
</blockquote>
<p>没有查到相关信息(先留一个坑)，猜测：<code>for-loop</code>中不能有两个<code>genvar</code>,于是不能出现<code>,</code> ,提示你要用<code>;</code></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Right Verion </span></span><br><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">399</span>:<span class="number">0</span>] a, b,</span><br><span class="line">    <span class="keyword">input</span> cin,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> cout,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">399</span>:<span class="number">0</span>] sum );</span><br><span class="line">    <span class="keyword">genvar</span> i ;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">99</span>:<span class="number">0</span>] temp_cout ;</span><br><span class="line">    <span class="keyword">assign</span> cout = temp_cout[<span class="number">99</span>] ;</span><br><span class="line">    <span class="keyword">generate</span></span><br><span class="line">        bcd_fadd U0( a[<span class="number">3</span>:<span class="number">0</span>] , b[<span class="number">3</span>:<span class="number">0</span>] , cin , temp_cout[<span class="number">0</span>] , sum[<span class="number">3</span>:<span class="number">0</span>]) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">7</span> ; i &lt; <span class="number">400</span> ;  i = i + <span class="number">4</span> ) <span class="keyword">begin</span> : name </span><br><span class="line">            bcd_fadd U1( a[i:i-<span class="number">3</span>] , b[i:i-<span class="number">3</span>] , temp_cout[(i + <span class="number">1</span>) / <span class="number">4</span> - <span class="number">2</span>] , temp_cout[(i + <span class="number">1</span>) / <span class="number">4</span> - <span class="number">1</span>] , sum[i:i-<span class="number">3</span>]) ;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>此处实现一下<code>bcd_fadd</code></strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> bcd_fadd(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span> : <span class="number">0</span>] a , b ,</span><br><span class="line">    <span class="keyword">input</span> cin , </span><br><span class="line">    <span class="keyword">output</span> cout ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] sum</span><br><span class="line">) ;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">4</span>:<span class="number">0</span>] temp ;</span><br><span class="line">    <span class="keyword">assign</span> temp = a + b + cin ;</span><br><span class="line">    <span class="keyword">assign</span> &#123;cout , sum&#125; = (temp&gt;<span class="number">9</span>) ? (temp+<span class="number">6</span>) : temp ; </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h1 id="Circuits"><a href="#Circuits" class="headerlink" title="Circuits"></a>Circuits</h1><h2 id="Combinational-Logic"><a href="#Combinational-Logic" class="headerlink" title="Combinational Logic"></a>Combinational Logic</h2><h3 id="Basic-Gates"><a href="#Basic-Gates" class="headerlink" title="Basic Gates"></a>Basic Gates</h3><h4 id="Even-longer-vectors"><a href="#Even-longer-vectors" class="headerlink" title="Even longer vectors"></a>Even longer vectors</h4><blockquote>
<p>See also the shorter version: <a href="https://hdlbits.01xz.net/wiki/gatesv">Gates and vectors</a>.</p>
<p>You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour:</p>
<ul>
<li><strong>out_both</strong>: Each bit of this output vector should indicate whether <em>both</em> the corresponding input bit and its neighbour to the <strong>left</strong> are ‘1’. For example, <code>out_both[98]</code> should indicate if <code>in[98]</code> and <code>in[99]</code> are both 1. Since <code>in[99]</code> has no neighbour to the left, the answer is obvious so we don’t need to know <code>out_both[99]</code>.</li>
<li><strong>out_any</strong>: Each bit of this output vector should indicate whether <em>any</em> of the corresponding input bit and its neighbour to the <strong>right</strong> are ‘1’. For example, <code>out_any[2]</code> should indicate if either <code>in[2]</code> or <code>in[1]</code> are 1. Since <code>in[0]</code> has no neighbour to the right, the answer is obvious so we don’t need to know <code>out_any[0]</code>.</li>
<li><strong>out_different</strong>: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the <strong>left</strong>. For example, <code>out_different[98]</code> should indicate if <code>in[98]</code> is different from <code>in[99]</code>. For this part, treat the vector as wrapping around, so <code>in[99]</code>‘s neighbour to the left is <code>in[0]</code>.</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//My vesion</span></span><br><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">98</span>:<span class="number">0</span>] out_both,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">99</span>:<span class="number">1</span>] out_any,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">99</span>:<span class="number">0</span>] out_different );</span><br><span class="line">    <span class="keyword">genvar</span> i ;</span><br><span class="line">	<span class="keyword">generate</span></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; <span class="number">99</span> ; i++ ) <span class="keyword">begin</span> : generate_name</span><br><span class="line">            <span class="keyword">assign</span> out_both[i] = in[i] &amp; in[i+<span class="number">1</span>] ;</span><br><span class="line">            <span class="keyword">assign</span> out_any[i+<span class="number">1</span>]= in[i+<span class="number">1</span>] | in[i] ;</span><br><span class="line">            <span class="keyword">assign</span> out_different[i] = in[i] ^ in[i+<span class="number">1</span>] ;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">assign</span> out_different[<span class="number">99</span>] = in[<span class="number">99</span>] ^ in[<span class="number">0</span>] ;</span><br><span class="line">    <span class="keyword">endgenerate</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Offical vesion</span></span><br><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">98</span>:<span class="number">0</span>] out_both,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">99</span>:<span class="number">1</span>] out_any,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">99</span>:<span class="number">0</span>] out_different );</span><br><span class="line">    <span class="keyword">assign</span> out_both = in[<span class="number">98</span>:<span class="number">0</span>] &amp; in[<span class="number">99</span>:<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">assign</span> out_any  = in[<span class="number">99</span>:<span class="number">1</span>] | in[<span class="number">98</span>:<span class="number">0</span>] ;</span><br><span class="line">    <span class="keyword">assign</span> out_different = in ^ &#123; in[<span class="number">0</span>] , in[<span class="number">99</span>:<span class="number">1</span>] &#125; ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h3 id="Multiplexers"><a href="#Multiplexers" class="headerlink" title="Multiplexers"></a>Multiplexers</h3><h4 id="9-to-1-multiplexer"><a href="#9-to-1-multiplexer" class="headerlink" title="9-to-1 multiplexer"></a>9-to-1 multiplexer</h4><blockquote>
<p>Create a 16-bit wide, 9-to-1 multiplexer. sel&#x3D;0 chooses a, sel&#x3D;1 chooses b, etc. For the unused cases (sel&#x3D;9 to 15), set all output bits to ‘1’.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Flase vesion</span></span><br><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] a, b, c, d, e, f, g, h, i,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] sel,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] out );</span><br><span class="line">    <span class="keyword">always</span> @(*)<span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">4&#x27;b0000</span> : out = a ;</span><br><span class="line">        <span class="number">4&#x27;b0001</span> : out = b ;</span><br><span class="line">        <span class="number">4&#x27;b0010</span> : out = c ;</span><br><span class="line">        <span class="number">4&#x27;b0011</span> : out = d ;</span><br><span class="line">        <span class="number">4&#x27;b0100</span> : out = e ;</span><br><span class="line">        <span class="number">4&#x27;b0101</span> : out = f ;</span><br><span class="line">        <span class="number">4&#x27;b0110</span> : out = g ;</span><br><span class="line">        <span class="number">4&#x27;b0111</span> : out = h ;</span><br><span class="line">        <span class="number">4&#x27;b1000</span> : out = i ;</span><br><span class="line">     	<span class="keyword">default</span> : out = <span class="number">16&#x27;hFFFF</span> ;<span class="comment">//十六进制应该为4&#x27;hFFFF</span></span><br><span class="line">        <span class="comment">//踩过的坑 ： out = 1 ; out = 0xFFFF ; out = 4&#x27;hFFFF</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span>      </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h4 id="256-to-1-4-bit-multiplexer"><a href="#256-to-1-4-bit-multiplexer" class="headerlink" title="256-to-1 4-bit multiplexer"></a>256-to-1 4-bit multiplexer</h4><blockquote>
<p>Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel&#x3D;0 should select bits <code>in[3:0]</code>, sel&#x3D;1 selects bits <code>in[7:4]</code>, sel&#x3D;2 selects bits <code>in[11:8]</code>, etc.</p>
</blockquote>
<blockquote>
<p>Hint</p>
<ul>
<li>With this many options, a case statement isn’t so useful.</li>
<li>Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It’s not always good at this. An error saying “… is not a constant” means it couldn’t prove that the select width is constant. In particular, <code>in[ sel*4+3 : sel*4 ]</code> does not work. &#x2F;&#x2F; verilog 索引不支持全为变量</li>
<li>Bit slicing (“Indexed vector part select”, since Verilog-2001) has an even more compact syntax.</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1023</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out );</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">assign</span> out = in[sel * <span class="number">4</span> + <span class="number">3</span> : sel * <span class="number">4</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>error : sel is not a constant File ;</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//True</span></span><br><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1023</span>:<span class="number">0</span>] in,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assign</span> out = in[sel * <span class="number">4</span>  +: <span class="number">4</span>] ;<span class="comment">//从sel*4向上四位</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Arithmetic-Circuits"><a href="#Arithmetic-Circuits" class="headerlink" title="Arithmetic Circuits"></a>Arithmetic Circuits</h3><h4 id="3-bit-binary-adder"><a href="#3-bit-binary-adder" class="headerlink" title="3-bit binary adder"></a>3-bit binary adder</h4><blockquote>
<p>Now that you know how to build a <a href="https://hdlbits.01xz.net/wiki/Fadd">full adder</a>, make 3 instances of it to create a 3-bit binary ripple-carry adder. The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. To encourage you to actually instantiate full adders, also output the carry-out from <em>each</em> full adder in the ripple-carry adder. cout[2] is the final carry-out from the last full adder, and is the carry-out you usually see.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">2</span>:<span class="number">0</span>] a, b,</span><br><span class="line">    <span class="keyword">input</span> cin,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] cout,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] sum );</span><br><span class="line">    full_adder ripple_adder_1( a[<span class="number">0</span>] , b[<span class="number">0</span>] , cin , cout[<span class="number">0</span>] , sum[<span class="number">0</span>] ) ;</span><br><span class="line">    full_adder ripple_adder_2( a[<span class="number">1</span>] , b[<span class="number">1</span>] , cout[<span class="number">0</span>] , cout[<span class="number">1</span>] , sum[<span class="number">1</span>] ) ;</span><br><span class="line">    full_adder ripple_adder_3( a[<span class="number">2</span>] , b[<span class="number">2</span>] , cout[<span class="number">1</span>] , cout[<span class="number">2</span>] , sum[<span class="number">2</span>] ) ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> full_adder(</span><br><span class="line">    <span class="keyword">input</span> a , b , cin , </span><br><span class="line">    <span class="keyword">output</span> cout , sum</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> cout= a &amp; b | a &amp; cin | b &amp; cin ;</span><br><span class="line">    <span class="keyword">assign</span> sum = a ^ b ^ cin ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="Signed-addition-overflow"><a href="#Signed-addition-overflow" class="headerlink" title="Signed addition overflow"></a>Signed addition overflow</h4><blockquote>
<p>Assume that you have two 8-bit 2’s complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Flase vesion</span></span><br><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] a,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] b,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] s,</span><br><span class="line">    <span class="keyword">output</span> overflow</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">assign</span> &#123; overflow , s &#125; = a + b ;</span><br><span class="line">    <span class="comment">//注意题中的signed overflow , 并不等于进位cout</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何检测符号溢出(<strong>signed overflow</strong>) : 符号不同，相加不会溢出  ； 符号相同，可能溢出，需要设置检测。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//True vesion</span></span><br><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] a , b ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span> : <span class="number">0</span>] s ,</span><br><span class="line">    <span class="keyword">output</span> overflow</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> s = a + b ;</span><br><span class="line">    <span class="keyword">assign</span> overflow = ( a[<span class="number">7</span>] == b[<span class="number">7</span>] ) ? (a[<span class="number">7</span>] ^ s[<span class="number">7</span>]) : <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="100-bit-binary-adder"><a href="#100-bit-binary-adder" class="headerlink" title="100-bit binary adder"></a>100-bit binary adder</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] a,</span><br><span class="line">	<span class="keyword">input</span> [<span class="number">99</span>:<span class="number">0</span>] b,</span><br><span class="line">	<span class="keyword">input</span> cin,</span><br><span class="line">	<span class="keyword">output</span> cout,</span><br><span class="line">	<span class="keyword">output</span> [<span class="number">99</span>:<span class="number">0</span>] sum</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The concatenation &#123;cout, sum&#125; is a 101-bit vector.</span></span><br><span class="line">	<span class="keyword">assign</span> &#123;cout, sum&#125; = a+b+cin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-digit-BCD-adder"><a href="#4-digit-BCD-adder" class="headerlink" title="4-digit BCD adder"></a>4-digit BCD adder</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module ( </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">15</span>:<span class="number">0</span>] a, b,</span><br><span class="line">    <span class="keyword">input</span> cin,</span><br><span class="line">    <span class="keyword">output</span> cout,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] sum );</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] temp_cout ;</span><br><span class="line">    bcd_fadd U0 ( a[<span class="number">3</span>:<span class="number">0</span>] , b[<span class="number">3</span>:<span class="number">0</span>] , cin ,  temp_cout[<span class="number">0</span>] , sum[<span class="number">3</span>:<span class="number">0</span>] ) ;</span><br><span class="line">    bcd_fadd U1 ( a[<span class="number">7</span>:<span class="number">4</span>] , b[<span class="number">7</span>:<span class="number">4</span>] , temp_cout[<span class="number">0</span>] ,  temp_cout[<span class="number">1</span>] , sum[<span class="number">7</span>:<span class="number">4</span>] ) ;</span><br><span class="line">    bcd_fadd U2 ( a[<span class="number">11</span>:<span class="number">8</span>] , b[<span class="number">11</span>:<span class="number">8</span>] , temp_cout[<span class="number">1</span>] ,  temp_cout[<span class="number">2</span>] , sum[<span class="number">11</span>:<span class="number">8</span>] ) ;</span><br><span class="line">    bcd_fadd U3 ( a[<span class="number">15</span>:<span class="number">12</span>] , b[<span class="number">15</span>:<span class="number">12</span>] , temp_cout[<span class="number">2</span>] ,  cout , sum[<span class="number">15</span>:<span class="number">12</span>] ) ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Karnaugh-Map-to-Citcuit"><a href="#Karnaugh-Map-to-Citcuit" class="headerlink" title="Karnaugh Map to Citcuit"></a>Karnaugh Map to Citcuit</h3><h4 id="3-variable"><a href="#3-variable" class="headerlink" title="3-variable"></a>3-variable</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">	<span class="keyword">input</span> a, </span><br><span class="line">	<span class="keyword">input</span> b,</span><br><span class="line">	<span class="keyword">input</span> c,</span><br><span class="line">	<span class="keyword">output</span> out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SOP form: Three prime implicants (1 term each), summed.</span></span><br><span class="line">	<span class="comment">// POS form: One prime implicant (of 3 terms)</span></span><br><span class="line">	<span class="comment">// In this particular case, the result is the same for both SOP and POS.</span></span><br><span class="line">    <span class="comment">// it&#x27;s easier by using SOP</span></span><br><span class="line">	<span class="keyword">assign</span> out = (a | b | c);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-variable"><a href="#4-variable" class="headerlink" title="4-variable"></a>4-variable</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">input</span> c,</span><br><span class="line">    <span class="keyword">input</span> d,</span><br><span class="line">    <span class="keyword">output</span> out  ); </span><br><span class="line">    <span class="keyword">assign</span> out = (!b &amp; !c) | (!a &amp; !d) | (!a &amp; b &amp; c) | (a &amp; c &amp; d)  ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-variable-1"><a href="#4-variable-1" class="headerlink" title="4-variable"></a>4-variable</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">input</span> c,</span><br><span class="line">    <span class="keyword">input</span> d,</span><br><span class="line">    <span class="keyword">output</span> out  ); </span><br><span class="line">    <span class="keyword">assign</span> out = a | (!b &amp; c) ;</span><br><span class="line">    <span class="comment">//用0去算！f更简单</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-variable-2"><a href="#4-variable-2" class="headerlink" title="4-variable"></a>4-variable</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Stupid vesion</span></span><br><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">input</span> c,</span><br><span class="line">    <span class="keyword">input</span> d,</span><br><span class="line">    <span class="keyword">output</span> out  ); </span><br><span class="line">    <span class="keyword">assign</span> out = (!a &amp; !b) &amp; (c ^ d) | (!a &amp; b) &amp; !(c ^ d) | a &amp; b &amp; (c ^ d) | (a &amp; !b) &amp; !(c ^ d);</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wise vesion</span></span><br><span class="line"><span class="keyword">module</span> top_module(</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">input</span> c,</span><br><span class="line">    <span class="keyword">input</span> d,</span><br><span class="line">    <span class="keyword">output</span> out  ); </span><br><span class="line">	<span class="keyword">assign</span> out = a ^ b ^ c ^ d ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<p><strong>如果会奇偶校验便能一眼看出：<code>abcd</code>中有奇数个<code>1</code>，卡诺图为<code>1</code> .反之为<code>0</code>.</strong></p>
<h4 id="Minimum-SOP-and-POS"><a href="#Minimum-SOP-and-POS" class="headerlink" title="Minimum SOP and POS"></a>Minimum SOP and POS</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> a,</span><br><span class="line">    <span class="keyword">input</span> b,</span><br><span class="line">    <span class="keyword">input</span> c,</span><br><span class="line">    <span class="keyword">input</span> d,</span><br><span class="line">    <span class="keyword">output</span> out_sop,</span><br><span class="line">    <span class="keyword">output</span> out_pos</span><br><span class="line">); </span><br><span class="line">	<span class="keyword">assign</span> out_sop = c &amp; d | !a &amp; !b &amp; c ;</span><br><span class="line">    <span class="keyword">assign</span> out_pos = c &amp; (!a | b) &amp; (!b | d) ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<h4 id="Karnaugh-map"><a href="#Karnaugh-map" class="headerlink" title="Karnaugh map"></a>Karnaugh map</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">1</span>] x, </span><br><span class="line">    <span class="keyword">output</span> f );</span><br><span class="line">    <span class="keyword">assign</span> f = !x[<span class="number">1</span>] &amp; x[<span class="number">3</span>] | x[<span class="number">1</span>] &amp; x[<span class="number">2</span>] &amp; !x[<span class="number">3</span>] ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Karnaugh-map-1"><a href="#Karnaugh-map-1" class="headerlink" title="Karnaugh map"></a>Karnaugh map</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">1</span>] x,</span><br><span class="line">    <span class="keyword">output</span> f</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">assign</span> f = (x[<span class="number">3</span>] | !x[<span class="number">4</span>]) &amp; (!x[<span class="number">2</span>] | x[<span class="number">3</span>] | x[<span class="number">4</span>]) &amp; (!x[<span class="number">1</span>] | x[<span class="number">2</span>] | !x[<span class="number">4</span>]) &amp; (!x[<span class="number">1</span>] | !x[<span class="number">2</span>] | x[<span class="number">4</span>]) ;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="K-map-implemented-with-a-multiplexer"><a href="#K-map-implemented-with-a-multiplexer" class="headerlink" title="K-map implemented with a multiplexer"></a>K-map implemented with a multiplexer</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> top_module (</span><br><span class="line">    <span class="keyword">input</span> c,</span><br><span class="line">    <span class="keyword">input</span> d,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] mux_in</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">always</span> @(*)<span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>( &#123; c , d &#125; )</span><br><span class="line">            <span class="number">2&#x27;b00</span> : mux_in = <span class="number">4&#x27;b0100</span> ;</span><br><span class="line">            <span class="number">2&#x27;b01</span> : mux_in = <span class="number">4&#x27;b0001</span> ;</span><br><span class="line">            <span class="number">2&#x27;b11</span> : mux_in = <span class="number">4&#x27;b1001</span> ;</span><br><span class="line">            <span class="number">2&#x27;b10</span> : mux_in = <span class="number">4&#x27;b0101</span> ;</span><br><span class="line">            <span class="keyword">default</span> : mux_in = <span class="number">4&#x27;b0000</span> ;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不完备 不一致 不可判定</p>
]]></content>
  </entry>
  <entry>
    <title>第一篇文章 网站搭建流程</title>
    <url>/2023/09/18/Hello%20Hexo-NEXT/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ostringstream <span class="title">oss</span><span class="params">(<span class="string">&quot;Ico-En Green Tea&quot;</span>)</span> </span>;</span><br><span class="line">    std::cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; std::endl ;</span><br><span class="line">    oss &lt;&lt; <span class="string">&quot;16.9 Ounces&quot;</span> ;</span><br><span class="line">    std::cout &lt;&lt; oss.<span class="built_in">str</span>() &lt;&lt; std::endl ;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Why so slow&quot;</span> &lt;&lt; std::endl ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h3><p>aaaaaaaaaaaaaaaa</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>bbbbbbbbbbbbbbb</p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>aaaaaaaaaaaaaaaaaaa</p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
</search>
